// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v6.33.2
// source: keymap/v1/onekeymap_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { EditorType, editorTypeFromJSON, editorTypeToJSON } from "./editor";
import { Action, Keymap } from "./keymap";

export const protobufPackage = "keymap.v1";

/** ImportKeymapRequest is the request message for ImportKeymap. */
export interface ImportKeymapRequest {
  /** The editor type. */
  editorType: EditorType;
  /** The source keymap file content in editor-specific config syntax */
  source: string;
  /** The base keymap to compare against in onekeymap config syntax */
  base: string;
}

/** ImportKeymapResponse is the response message for ImportKeymap. */
export interface ImportKeymapResponse {
  /** The imported keymap. */
  keymap:
    | Keymap
    | undefined;
  /** The changes between the base and the imported keymap. */
  changes: KeymapChanges | undefined;
}

/** KeymapChanges represents the changes to a keymap setting. */
export interface KeymapChanges {
  /** The keymaps that are added. */
  add: Action[];
  /** The keymaps that are removed. */
  remove: Action[];
  /** The keymaps that are updated. */
  update: ActionDiff[];
}

/** ActionDiff represents the diff of a keymap. */
export interface ActionDiff {
  /** The keymap before the change. */
  origin:
    | Action
    | undefined;
  /** The keymap after the change. */
  updated: Action | undefined;
}

/** ExportKeymapRequest is the request message for ExportKeymap. */
export interface ExportKeymapRequest {
  /** The editor type. */
  editorType: EditorType;
  /** The keymap to export. */
  keymap:
    | Keymap
    | undefined;
  /** The base keymap to compare against. */
  base: string;
  /** The diff type to use for the export. */
  diffType: ExportKeymapRequest_DiffType;
  /** Optional, file path for the keymap config */
  filePath: string;
}

/** The diff type for exporting. */
export enum ExportKeymapRequest_DiffType {
  /** DIFF_TYPE_UNSPECIFIED - Unspecified diff type. */
  DIFF_TYPE_UNSPECIFIED = 0,
  /** ASCII_DIFF - ASCII diff. */
  ASCII_DIFF = 1,
  /** UNIFIED_DIFF - Unified diff format. */
  UNIFIED_DIFF = 2,
  UNRECOGNIZED = -1,
}

export function exportKeymapRequest_DiffTypeFromJSON(object: any): ExportKeymapRequest_DiffType {
  switch (object) {
    case 0:
    case "DIFF_TYPE_UNSPECIFIED":
      return ExportKeymapRequest_DiffType.DIFF_TYPE_UNSPECIFIED;
    case 1:
    case "ASCII_DIFF":
      return ExportKeymapRequest_DiffType.ASCII_DIFF;
    case 2:
    case "UNIFIED_DIFF":
      return ExportKeymapRequest_DiffType.UNIFIED_DIFF;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExportKeymapRequest_DiffType.UNRECOGNIZED;
  }
}

export function exportKeymapRequest_DiffTypeToJSON(object: ExportKeymapRequest_DiffType): string {
  switch (object) {
    case ExportKeymapRequest_DiffType.DIFF_TYPE_UNSPECIFIED:
      return "DIFF_TYPE_UNSPECIFIED";
    case ExportKeymapRequest_DiffType.ASCII_DIFF:
      return "ASCII_DIFF";
    case ExportKeymapRequest_DiffType.UNIFIED_DIFF:
      return "UNIFIED_DIFF";
    case ExportKeymapRequest_DiffType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ExportKeymapResponse is the response message for ExportKeymap. */
export interface ExportKeymapResponse {
  /** The exported keymap config, editor-specific. */
  keymap: string;
  /** The diff between the original editor-specific keymap config and the exported keymap. */
  diff: string;
}

/** ConfigDetectRequest is the request message for ConfigDetect. */
export interface ConfigDetectRequest {
  /** The editor type. */
  editorType: EditorType;
}

/** ConfigDetectResponse is the response message for ConfigDetect. */
export interface ConfigDetectResponse {
  /** The default config paths. */
  paths: string[];
}

/** GetKeymapRequest is the request message for GetKeymap. */
export interface GetKeymapRequest {
  /** The config content in onekeymap.json format. */
  config: string;
  /** Whether to return all keymaps even when there are no bindings yet. */
  returnAll: boolean;
}

/** GetKeymapResponse is the response message for GetKeymap. */
export interface GetKeymapResponse {
  /** The loaded keymap. */
  keymap: Keymap | undefined;
}

/** SaveKeymapRequest is the request message for SaveKeymap. */
export interface SaveKeymapRequest {
  /** The keymap to save. */
  keymap: Keymap | undefined;
}

/** SaveKeymapResponse is the response message for SaveKeymap. */
export interface SaveKeymapResponse {
  /** The saved config content in onekeymap.json format */
  config: string;
}

function createBaseImportKeymapRequest(): ImportKeymapRequest {
  return { editorType: 0, source: "", base: "" };
}

export const ImportKeymapRequest: MessageFns<ImportKeymapRequest> = {
  encode(message: ImportKeymapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.editorType !== 0) {
      writer.uint32(8).int32(message.editorType);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.base !== "") {
      writer.uint32(26).string(message.base);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportKeymapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportKeymapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.editorType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.base = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportKeymapRequest {
    return {
      editorType: isSet(object.editorType)
        ? editorTypeFromJSON(object.editorType)
        : isSet(object.editor_type)
        ? editorTypeFromJSON(object.editor_type)
        : 0,
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      base: isSet(object.base) ? globalThis.String(object.base) : "",
    };
  },

  toJSON(message: ImportKeymapRequest): unknown {
    const obj: any = {};
    if (message.editorType !== 0) {
      obj.editorType = editorTypeToJSON(message.editorType);
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.base !== "") {
      obj.base = message.base;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportKeymapRequest>, I>>(base?: I): ImportKeymapRequest {
    return ImportKeymapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportKeymapRequest>, I>>(object: I): ImportKeymapRequest {
    const message = createBaseImportKeymapRequest();
    message.editorType = object.editorType ?? 0;
    message.source = object.source ?? "";
    message.base = object.base ?? "";
    return message;
  },
};

function createBaseImportKeymapResponse(): ImportKeymapResponse {
  return { keymap: undefined, changes: undefined };
}

export const ImportKeymapResponse: MessageFns<ImportKeymapResponse> = {
  encode(message: ImportKeymapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keymap !== undefined) {
      Keymap.encode(message.keymap, writer.uint32(10).fork()).join();
    }
    if (message.changes !== undefined) {
      KeymapChanges.encode(message.changes, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportKeymapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportKeymapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keymap = Keymap.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.changes = KeymapChanges.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportKeymapResponse {
    return {
      keymap: isSet(object.keymap) ? Keymap.fromJSON(object.keymap) : undefined,
      changes: isSet(object.changes) ? KeymapChanges.fromJSON(object.changes) : undefined,
    };
  },

  toJSON(message: ImportKeymapResponse): unknown {
    const obj: any = {};
    if (message.keymap !== undefined) {
      obj.keymap = Keymap.toJSON(message.keymap);
    }
    if (message.changes !== undefined) {
      obj.changes = KeymapChanges.toJSON(message.changes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportKeymapResponse>, I>>(base?: I): ImportKeymapResponse {
    return ImportKeymapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportKeymapResponse>, I>>(object: I): ImportKeymapResponse {
    const message = createBaseImportKeymapResponse();
    message.keymap = (object.keymap !== undefined && object.keymap !== null)
      ? Keymap.fromPartial(object.keymap)
      : undefined;
    message.changes = (object.changes !== undefined && object.changes !== null)
      ? KeymapChanges.fromPartial(object.changes)
      : undefined;
    return message;
  },
};

function createBaseKeymapChanges(): KeymapChanges {
  return { add: [], remove: [], update: [] };
}

export const KeymapChanges: MessageFns<KeymapChanges> = {
  encode(message: KeymapChanges, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.add) {
      Action.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.remove) {
      Action.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.update) {
      ActionDiff.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeymapChanges {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeymapChanges();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.add.push(Action.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.remove.push(Action.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.update.push(ActionDiff.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeymapChanges {
    return {
      add: globalThis.Array.isArray(object?.add) ? object.add.map((e: any) => Action.fromJSON(e)) : [],
      remove: globalThis.Array.isArray(object?.remove) ? object.remove.map((e: any) => Action.fromJSON(e)) : [],
      update: globalThis.Array.isArray(object?.update) ? object.update.map((e: any) => ActionDiff.fromJSON(e)) : [],
    };
  },

  toJSON(message: KeymapChanges): unknown {
    const obj: any = {};
    if (message.add?.length) {
      obj.add = message.add.map((e) => Action.toJSON(e));
    }
    if (message.remove?.length) {
      obj.remove = message.remove.map((e) => Action.toJSON(e));
    }
    if (message.update?.length) {
      obj.update = message.update.map((e) => ActionDiff.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeymapChanges>, I>>(base?: I): KeymapChanges {
    return KeymapChanges.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeymapChanges>, I>>(object: I): KeymapChanges {
    const message = createBaseKeymapChanges();
    message.add = object.add?.map((e) => Action.fromPartial(e)) || [];
    message.remove = object.remove?.map((e) => Action.fromPartial(e)) || [];
    message.update = object.update?.map((e) => ActionDiff.fromPartial(e)) || [];
    return message;
  },
};

function createBaseActionDiff(): ActionDiff {
  return { origin: undefined, updated: undefined };
}

export const ActionDiff: MessageFns<ActionDiff> = {
  encode(message: ActionDiff, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.origin !== undefined) {
      Action.encode(message.origin, writer.uint32(10).fork()).join();
    }
    if (message.updated !== undefined) {
      Action.encode(message.updated, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionDiff {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionDiff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.origin = Action.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updated = Action.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionDiff {
    return {
      origin: isSet(object.origin) ? Action.fromJSON(object.origin) : undefined,
      updated: isSet(object.updated) ? Action.fromJSON(object.updated) : undefined,
    };
  },

  toJSON(message: ActionDiff): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = Action.toJSON(message.origin);
    }
    if (message.updated !== undefined) {
      obj.updated = Action.toJSON(message.updated);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActionDiff>, I>>(base?: I): ActionDiff {
    return ActionDiff.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActionDiff>, I>>(object: I): ActionDiff {
    const message = createBaseActionDiff();
    message.origin = (object.origin !== undefined && object.origin !== null)
      ? Action.fromPartial(object.origin)
      : undefined;
    message.updated = (object.updated !== undefined && object.updated !== null)
      ? Action.fromPartial(object.updated)
      : undefined;
    return message;
  },
};

function createBaseExportKeymapRequest(): ExportKeymapRequest {
  return { editorType: 0, keymap: undefined, base: "", diffType: 0, filePath: "" };
}

export const ExportKeymapRequest: MessageFns<ExportKeymapRequest> = {
  encode(message: ExportKeymapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.editorType !== 0) {
      writer.uint32(8).int32(message.editorType);
    }
    if (message.keymap !== undefined) {
      Keymap.encode(message.keymap, writer.uint32(18).fork()).join();
    }
    if (message.base !== "") {
      writer.uint32(26).string(message.base);
    }
    if (message.diffType !== 0) {
      writer.uint32(32).int32(message.diffType);
    }
    if (message.filePath !== "") {
      writer.uint32(42).string(message.filePath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportKeymapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportKeymapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.editorType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keymap = Keymap.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.base = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.diffType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filePath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportKeymapRequest {
    return {
      editorType: isSet(object.editorType)
        ? editorTypeFromJSON(object.editorType)
        : isSet(object.editor_type)
        ? editorTypeFromJSON(object.editor_type)
        : 0,
      keymap: isSet(object.keymap) ? Keymap.fromJSON(object.keymap) : undefined,
      base: isSet(object.base) ? globalThis.String(object.base) : "",
      diffType: isSet(object.diffType)
        ? exportKeymapRequest_DiffTypeFromJSON(object.diffType)
        : isSet(object.diff_type)
        ? exportKeymapRequest_DiffTypeFromJSON(object.diff_type)
        : 0,
      filePath: isSet(object.filePath)
        ? globalThis.String(object.filePath)
        : isSet(object.file_path)
        ? globalThis.String(object.file_path)
        : "",
    };
  },

  toJSON(message: ExportKeymapRequest): unknown {
    const obj: any = {};
    if (message.editorType !== 0) {
      obj.editorType = editorTypeToJSON(message.editorType);
    }
    if (message.keymap !== undefined) {
      obj.keymap = Keymap.toJSON(message.keymap);
    }
    if (message.base !== "") {
      obj.base = message.base;
    }
    if (message.diffType !== 0) {
      obj.diffType = exportKeymapRequest_DiffTypeToJSON(message.diffType);
    }
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportKeymapRequest>, I>>(base?: I): ExportKeymapRequest {
    return ExportKeymapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportKeymapRequest>, I>>(object: I): ExportKeymapRequest {
    const message = createBaseExportKeymapRequest();
    message.editorType = object.editorType ?? 0;
    message.keymap = (object.keymap !== undefined && object.keymap !== null)
      ? Keymap.fromPartial(object.keymap)
      : undefined;
    message.base = object.base ?? "";
    message.diffType = object.diffType ?? 0;
    message.filePath = object.filePath ?? "";
    return message;
  },
};

function createBaseExportKeymapResponse(): ExportKeymapResponse {
  return { keymap: "", diff: "" };
}

export const ExportKeymapResponse: MessageFns<ExportKeymapResponse> = {
  encode(message: ExportKeymapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keymap !== "") {
      writer.uint32(10).string(message.keymap);
    }
    if (message.diff !== "") {
      writer.uint32(18).string(message.diff);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportKeymapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportKeymapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keymap = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.diff = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportKeymapResponse {
    return {
      keymap: isSet(object.keymap) ? globalThis.String(object.keymap) : "",
      diff: isSet(object.diff) ? globalThis.String(object.diff) : "",
    };
  },

  toJSON(message: ExportKeymapResponse): unknown {
    const obj: any = {};
    if (message.keymap !== "") {
      obj.keymap = message.keymap;
    }
    if (message.diff !== "") {
      obj.diff = message.diff;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportKeymapResponse>, I>>(base?: I): ExportKeymapResponse {
    return ExportKeymapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportKeymapResponse>, I>>(object: I): ExportKeymapResponse {
    const message = createBaseExportKeymapResponse();
    message.keymap = object.keymap ?? "";
    message.diff = object.diff ?? "";
    return message;
  },
};

function createBaseConfigDetectRequest(): ConfigDetectRequest {
  return { editorType: 0 };
}

export const ConfigDetectRequest: MessageFns<ConfigDetectRequest> = {
  encode(message: ConfigDetectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.editorType !== 0) {
      writer.uint32(8).int32(message.editorType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigDetectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigDetectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.editorType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigDetectRequest {
    return {
      editorType: isSet(object.editorType)
        ? editorTypeFromJSON(object.editorType)
        : isSet(object.editor_type)
        ? editorTypeFromJSON(object.editor_type)
        : 0,
    };
  },

  toJSON(message: ConfigDetectRequest): unknown {
    const obj: any = {};
    if (message.editorType !== 0) {
      obj.editorType = editorTypeToJSON(message.editorType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigDetectRequest>, I>>(base?: I): ConfigDetectRequest {
    return ConfigDetectRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigDetectRequest>, I>>(object: I): ConfigDetectRequest {
    const message = createBaseConfigDetectRequest();
    message.editorType = object.editorType ?? 0;
    return message;
  },
};

function createBaseConfigDetectResponse(): ConfigDetectResponse {
  return { paths: [] };
}

export const ConfigDetectResponse: MessageFns<ConfigDetectResponse> = {
  encode(message: ConfigDetectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.paths) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigDetectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigDetectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paths.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigDetectResponse {
    return { paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: ConfigDetectResponse): unknown {
    const obj: any = {};
    if (message.paths?.length) {
      obj.paths = message.paths;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigDetectResponse>, I>>(base?: I): ConfigDetectResponse {
    return ConfigDetectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigDetectResponse>, I>>(object: I): ConfigDetectResponse {
    const message = createBaseConfigDetectResponse();
    message.paths = object.paths?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetKeymapRequest(): GetKeymapRequest {
  return { config: "", returnAll: false };
}

export const GetKeymapRequest: MessageFns<GetKeymapRequest> = {
  encode(message: GetKeymapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== "") {
      writer.uint32(10).string(message.config);
    }
    if (message.returnAll !== false) {
      writer.uint32(16).bool(message.returnAll);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKeymapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKeymapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.returnAll = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKeymapRequest {
    return {
      config: isSet(object.config) ? globalThis.String(object.config) : "",
      returnAll: isSet(object.returnAll)
        ? globalThis.Boolean(object.returnAll)
        : isSet(object.return_all)
        ? globalThis.Boolean(object.return_all)
        : false,
    };
  },

  toJSON(message: GetKeymapRequest): unknown {
    const obj: any = {};
    if (message.config !== "") {
      obj.config = message.config;
    }
    if (message.returnAll !== false) {
      obj.returnAll = message.returnAll;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetKeymapRequest>, I>>(base?: I): GetKeymapRequest {
    return GetKeymapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetKeymapRequest>, I>>(object: I): GetKeymapRequest {
    const message = createBaseGetKeymapRequest();
    message.config = object.config ?? "";
    message.returnAll = object.returnAll ?? false;
    return message;
  },
};

function createBaseGetKeymapResponse(): GetKeymapResponse {
  return { keymap: undefined };
}

export const GetKeymapResponse: MessageFns<GetKeymapResponse> = {
  encode(message: GetKeymapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keymap !== undefined) {
      Keymap.encode(message.keymap, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKeymapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKeymapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keymap = Keymap.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKeymapResponse {
    return { keymap: isSet(object.keymap) ? Keymap.fromJSON(object.keymap) : undefined };
  },

  toJSON(message: GetKeymapResponse): unknown {
    const obj: any = {};
    if (message.keymap !== undefined) {
      obj.keymap = Keymap.toJSON(message.keymap);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetKeymapResponse>, I>>(base?: I): GetKeymapResponse {
    return GetKeymapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetKeymapResponse>, I>>(object: I): GetKeymapResponse {
    const message = createBaseGetKeymapResponse();
    message.keymap = (object.keymap !== undefined && object.keymap !== null)
      ? Keymap.fromPartial(object.keymap)
      : undefined;
    return message;
  },
};

function createBaseSaveKeymapRequest(): SaveKeymapRequest {
  return { keymap: undefined };
}

export const SaveKeymapRequest: MessageFns<SaveKeymapRequest> = {
  encode(message: SaveKeymapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keymap !== undefined) {
      Keymap.encode(message.keymap, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SaveKeymapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveKeymapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keymap = Keymap.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SaveKeymapRequest {
    return { keymap: isSet(object.keymap) ? Keymap.fromJSON(object.keymap) : undefined };
  },

  toJSON(message: SaveKeymapRequest): unknown {
    const obj: any = {};
    if (message.keymap !== undefined) {
      obj.keymap = Keymap.toJSON(message.keymap);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SaveKeymapRequest>, I>>(base?: I): SaveKeymapRequest {
    return SaveKeymapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SaveKeymapRequest>, I>>(object: I): SaveKeymapRequest {
    const message = createBaseSaveKeymapRequest();
    message.keymap = (object.keymap !== undefined && object.keymap !== null)
      ? Keymap.fromPartial(object.keymap)
      : undefined;
    return message;
  },
};

function createBaseSaveKeymapResponse(): SaveKeymapResponse {
  return { config: "" };
}

export const SaveKeymapResponse: MessageFns<SaveKeymapResponse> = {
  encode(message: SaveKeymapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== "") {
      writer.uint32(10).string(message.config);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SaveKeymapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveKeymapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SaveKeymapResponse {
    return { config: isSet(object.config) ? globalThis.String(object.config) : "" };
  },

  toJSON(message: SaveKeymapResponse): unknown {
    const obj: any = {};
    if (message.config !== "") {
      obj.config = message.config;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SaveKeymapResponse>, I>>(base?: I): SaveKeymapResponse {
    return SaveKeymapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SaveKeymapResponse>, I>>(object: I): SaveKeymapResponse {
    const message = createBaseSaveKeymapResponse();
    message.config = object.config ?? "";
    return message;
  },
};

/** OnekeymapService provides APIs for managing keymap settings for the UI. */
export type OnekeymapServiceService = typeof OnekeymapServiceService;
export const OnekeymapServiceService = {
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: OnekeymapService only support grpc --)
   * ImportKeymap imports editor-specific config file
   */
  importKeymap: {
    path: "/keymap.v1.OnekeymapService/ImportKeymap",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ImportKeymapRequest): Buffer => Buffer.from(ImportKeymapRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ImportKeymapRequest => ImportKeymapRequest.decode(value),
    responseSerialize: (value: ImportKeymapResponse): Buffer =>
      Buffer.from(ImportKeymapResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ImportKeymapResponse => ImportKeymapResponse.decode(value),
  },
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: OnekeymapService only support grpc --)
   * ExportKeymap exports the current keymap settings.
   */
  exportKeymap: {
    path: "/keymap.v1.OnekeymapService/ExportKeymap",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExportKeymapRequest): Buffer => Buffer.from(ExportKeymapRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExportKeymapRequest => ExportKeymapRequest.decode(value),
    responseSerialize: (value: ExportKeymapResponse): Buffer =>
      Buffer.from(ExportKeymapResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExportKeymapResponse => ExportKeymapResponse.decode(value),
  },
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: OnekeymapService only support grpc --)
   * ConfigDetect returns the default config path.
   */
  configDetect: {
    path: "/keymap.v1.OnekeymapService/ConfigDetect",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ConfigDetectRequest): Buffer => Buffer.from(ConfigDetectRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ConfigDetectRequest => ConfigDetectRequest.decode(value),
    responseSerialize: (value: ConfigDetectResponse): Buffer =>
      Buffer.from(ConfigDetectResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ConfigDetectResponse => ConfigDetectResponse.decode(value),
  },
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: OnekeymapService only support grpc --)
   * (-- api-linter: core::0131::response-message-name=disabled
   *     aip.dev/not-precedent: GetKeymap is not a standard Get method, it loads from config content --)
   * (-- api-linter: core::0131::request-unknown-fields=disabled
   *     aip.dev/not-precedent: GetKeymap uses config content, not resource name --)
   * (-- api-linter: core::0131::request-name-required=disabled
   *     aip.dev/not-precedent: GetKeymap uses config content, not resource name --)
   * GetKeymap loads a keymap from a text content.
   */
  getKeymap: {
    path: "/keymap.v1.OnekeymapService/GetKeymap",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetKeymapRequest): Buffer => Buffer.from(GetKeymapRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetKeymapRequest => GetKeymapRequest.decode(value),
    responseSerialize: (value: GetKeymapResponse): Buffer => Buffer.from(GetKeymapResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetKeymapResponse => GetKeymapResponse.decode(value),
  },
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: OnekeymapService only support grpc --)
   * SaveKeymap saves the current keymap settings to a text content.
   */
  saveKeymap: {
    path: "/keymap.v1.OnekeymapService/SaveKeymap",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SaveKeymapRequest): Buffer => Buffer.from(SaveKeymapRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SaveKeymapRequest => SaveKeymapRequest.decode(value),
    responseSerialize: (value: SaveKeymapResponse): Buffer => Buffer.from(SaveKeymapResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SaveKeymapResponse => SaveKeymapResponse.decode(value),
  },
} as const;

export interface OnekeymapServiceServer extends UntypedServiceImplementation {
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: OnekeymapService only support grpc --)
   * ImportKeymap imports editor-specific config file
   */
  importKeymap: handleUnaryCall<ImportKeymapRequest, ImportKeymapResponse>;
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: OnekeymapService only support grpc --)
   * ExportKeymap exports the current keymap settings.
   */
  exportKeymap: handleUnaryCall<ExportKeymapRequest, ExportKeymapResponse>;
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: OnekeymapService only support grpc --)
   * ConfigDetect returns the default config path.
   */
  configDetect: handleUnaryCall<ConfigDetectRequest, ConfigDetectResponse>;
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: OnekeymapService only support grpc --)
   * (-- api-linter: core::0131::response-message-name=disabled
   *     aip.dev/not-precedent: GetKeymap is not a standard Get method, it loads from config content --)
   * (-- api-linter: core::0131::request-unknown-fields=disabled
   *     aip.dev/not-precedent: GetKeymap uses config content, not resource name --)
   * (-- api-linter: core::0131::request-name-required=disabled
   *     aip.dev/not-precedent: GetKeymap uses config content, not resource name --)
   * GetKeymap loads a keymap from a text content.
   */
  getKeymap: handleUnaryCall<GetKeymapRequest, GetKeymapResponse>;
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: OnekeymapService only support grpc --)
   * SaveKeymap saves the current keymap settings to a text content.
   */
  saveKeymap: handleUnaryCall<SaveKeymapRequest, SaveKeymapResponse>;
}

export interface OnekeymapServiceClient extends Client {
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: OnekeymapService only support grpc --)
   * ImportKeymap imports editor-specific config file
   */
  importKeymap(
    request: ImportKeymapRequest,
    callback: (error: ServiceError | null, response: ImportKeymapResponse) => void,
  ): ClientUnaryCall;
  importKeymap(
    request: ImportKeymapRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ImportKeymapResponse) => void,
  ): ClientUnaryCall;
  importKeymap(
    request: ImportKeymapRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ImportKeymapResponse) => void,
  ): ClientUnaryCall;
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: OnekeymapService only support grpc --)
   * ExportKeymap exports the current keymap settings.
   */
  exportKeymap(
    request: ExportKeymapRequest,
    callback: (error: ServiceError | null, response: ExportKeymapResponse) => void,
  ): ClientUnaryCall;
  exportKeymap(
    request: ExportKeymapRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ExportKeymapResponse) => void,
  ): ClientUnaryCall;
  exportKeymap(
    request: ExportKeymapRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ExportKeymapResponse) => void,
  ): ClientUnaryCall;
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: OnekeymapService only support grpc --)
   * ConfigDetect returns the default config path.
   */
  configDetect(
    request: ConfigDetectRequest,
    callback: (error: ServiceError | null, response: ConfigDetectResponse) => void,
  ): ClientUnaryCall;
  configDetect(
    request: ConfigDetectRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ConfigDetectResponse) => void,
  ): ClientUnaryCall;
  configDetect(
    request: ConfigDetectRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ConfigDetectResponse) => void,
  ): ClientUnaryCall;
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: OnekeymapService only support grpc --)
   * (-- api-linter: core::0131::response-message-name=disabled
   *     aip.dev/not-precedent: GetKeymap is not a standard Get method, it loads from config content --)
   * (-- api-linter: core::0131::request-unknown-fields=disabled
   *     aip.dev/not-precedent: GetKeymap uses config content, not resource name --)
   * (-- api-linter: core::0131::request-name-required=disabled
   *     aip.dev/not-precedent: GetKeymap uses config content, not resource name --)
   * GetKeymap loads a keymap from a text content.
   */
  getKeymap(
    request: GetKeymapRequest,
    callback: (error: ServiceError | null, response: GetKeymapResponse) => void,
  ): ClientUnaryCall;
  getKeymap(
    request: GetKeymapRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetKeymapResponse) => void,
  ): ClientUnaryCall;
  getKeymap(
    request: GetKeymapRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetKeymapResponse) => void,
  ): ClientUnaryCall;
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: OnekeymapService only support grpc --)
   * SaveKeymap saves the current keymap settings to a text content.
   */
  saveKeymap(
    request: SaveKeymapRequest,
    callback: (error: ServiceError | null, response: SaveKeymapResponse) => void,
  ): ClientUnaryCall;
  saveKeymap(
    request: SaveKeymapRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SaveKeymapResponse) => void,
  ): ClientUnaryCall;
  saveKeymap(
    request: SaveKeymapRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SaveKeymapResponse) => void,
  ): ClientUnaryCall;
}

export const OnekeymapServiceClient = makeGenericClientConstructor(
  OnekeymapServiceService,
  "keymap.v1.OnekeymapService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): OnekeymapServiceClient;
  service: typeof OnekeymapServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
