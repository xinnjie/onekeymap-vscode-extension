// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: keymap/v1/validation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "keymap.v1";

/** ValidationReport is the overall report of a validation run. */
export interface ValidationReport {
  /** The source editor of the validation run. */
  sourceEditor: string;
  /** The summary of the validation run. */
  summary:
    | Summary
    | undefined;
  /** The issues detected during the validation run. */
  issues: ValidationIssue[];
  /**
   * The warnings issued during the validation run.
   * Warnings are just issues that tend to not harm
   */
  warnings: ValidationIssue[];
}

/** Summary is the summary of a validation run. */
export interface Summary {
  /** The total number of mappings processed. */
  mappingsProcessed: number;
  /** The number of mappings that succeeded. */
  mappingsSucceeded: number;
}

/** ValidationIssue is a single issue detected during validation. */
export interface ValidationIssue {
  /** KeybindConflict is that multiple actions are mapped to the same keybinding. */
  keybindConflict?:
    | KeybindConflict
    | undefined;
  /** DanglingAction is that an action is mapped to a keybinding that does not exist. */
  danglingAction?:
    | DanglingAction
    | undefined;
  /** UnsupportedAction is that an action is mapped to a keybinding that is not supported by the target editor. */
  unsupportedAction?:
    | UnsupportedAction
    | undefined;
  /** DuplicateMapping is that the same action and keybinding combination appears multiple times. */
  duplicateMapping?:
    | DuplicateMapping
    | undefined;
  /** PotentialShadowing is that a keybinding might shadow a critical system shortcut. */
  potentialShadowing?: PotentialShadowing | undefined;
}

/** KeybindConflict is a keybinding conflict detected during validation. */
export interface KeybindConflict {
  /** The keybinding that is in conflict. */
  keybinding: string;
  /** The actions that are in conflict. */
  actions: KeybindConflict_Action[];
}

/** Action is an action mapped to a editor command. */
export interface KeybindConflict_Action {
  /** The action identifier. */
  action: string;
  /** The editor command. */
  editorCommand: string;
}

/** DanglingAction is a dangling action detected during validation. */
export interface DanglingAction {
  /** The action that is dangling. */
  action: string;
  /** The keybinding that is dangling. */
  keybinding: string;
  /** The suggestion for the dangling action. */
  suggestion: string;
}

/** UnsupportedAction is an unsupported action detected during validation. */
export interface UnsupportedAction {
  /** The action that is unsupported. */
  action: string;
  /** The keybinding that is unsupported. */
  keybinding: string;
  /** The target editor that the action is unsupported for. */
  targetEditor: string;
}

/** DuplicateMapping is a duplicate mapping detected during validation. */
export interface DuplicateMapping {
  /** The action that has duplicate mappings. */
  action: string;
  /** The keybinding that is duplicated. */
  keybinding: string;
  /** A message describing the issue. */
  message: string;
}

/** PotentialShadowing is a keybinding that might shadow a critical system shortcut. */
export interface PotentialShadowing {
  /** The keybinding that might cause shadowing. */
  keybinding: string;
  /** The action mapped to this keybinding. */
  action: string;
  /** The target editor where shadowing might occur. */
  targetEditor: string;
  /** A message describing the potential issue. */
  message: string;
}

function createBaseValidationReport(): ValidationReport {
  return { sourceEditor: "", summary: undefined, issues: [], warnings: [] };
}

export const ValidationReport: MessageFns<ValidationReport> = {
  encode(message: ValidationReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceEditor !== "") {
      writer.uint32(10).string(message.sourceEditor);
    }
    if (message.summary !== undefined) {
      Summary.encode(message.summary, writer.uint32(18).fork()).join();
    }
    for (const v of message.issues) {
      ValidationIssue.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.warnings) {
      ValidationIssue.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceEditor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.summary = Summary.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.issues.push(ValidationIssue.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.warnings.push(ValidationIssue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationReport {
    return {
      sourceEditor: isSet(object.sourceEditor)
        ? globalThis.String(object.sourceEditor)
        : isSet(object.source_editor)
        ? globalThis.String(object.source_editor)
        : "",
      summary: isSet(object.summary) ? Summary.fromJSON(object.summary) : undefined,
      issues: globalThis.Array.isArray(object?.issues)
        ? object.issues.map((e: any) => ValidationIssue.fromJSON(e))
        : [],
      warnings: globalThis.Array.isArray(object?.warnings)
        ? object.warnings.map((e: any) => ValidationIssue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ValidationReport): unknown {
    const obj: any = {};
    if (message.sourceEditor !== "") {
      obj.sourceEditor = message.sourceEditor;
    }
    if (message.summary !== undefined) {
      obj.summary = Summary.toJSON(message.summary);
    }
    if (message.issues?.length) {
      obj.issues = message.issues.map((e) => ValidationIssue.toJSON(e));
    }
    if (message.warnings?.length) {
      obj.warnings = message.warnings.map((e) => ValidationIssue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidationReport>, I>>(base?: I): ValidationReport {
    return ValidationReport.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidationReport>, I>>(object: I): ValidationReport {
    const message = createBaseValidationReport();
    message.sourceEditor = object.sourceEditor ?? "";
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? Summary.fromPartial(object.summary)
      : undefined;
    message.issues = object.issues?.map((e) => ValidationIssue.fromPartial(e)) || [];
    message.warnings = object.warnings?.map((e) => ValidationIssue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSummary(): Summary {
  return { mappingsProcessed: 0, mappingsSucceeded: 0 };
}

export const Summary: MessageFns<Summary> = {
  encode(message: Summary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mappingsProcessed !== 0) {
      writer.uint32(8).int32(message.mappingsProcessed);
    }
    if (message.mappingsSucceeded !== 0) {
      writer.uint32(16).int32(message.mappingsSucceeded);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Summary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mappingsProcessed = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mappingsSucceeded = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Summary {
    return {
      mappingsProcessed: isSet(object.mappingsProcessed)
        ? globalThis.Number(object.mappingsProcessed)
        : isSet(object.mappings_processed)
        ? globalThis.Number(object.mappings_processed)
        : 0,
      mappingsSucceeded: isSet(object.mappingsSucceeded)
        ? globalThis.Number(object.mappingsSucceeded)
        : isSet(object.mappings_succeeded)
        ? globalThis.Number(object.mappings_succeeded)
        : 0,
    };
  },

  toJSON(message: Summary): unknown {
    const obj: any = {};
    if (message.mappingsProcessed !== 0) {
      obj.mappingsProcessed = Math.round(message.mappingsProcessed);
    }
    if (message.mappingsSucceeded !== 0) {
      obj.mappingsSucceeded = Math.round(message.mappingsSucceeded);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Summary>, I>>(base?: I): Summary {
    return Summary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Summary>, I>>(object: I): Summary {
    const message = createBaseSummary();
    message.mappingsProcessed = object.mappingsProcessed ?? 0;
    message.mappingsSucceeded = object.mappingsSucceeded ?? 0;
    return message;
  },
};

function createBaseValidationIssue(): ValidationIssue {
  return {
    keybindConflict: undefined,
    danglingAction: undefined,
    unsupportedAction: undefined,
    duplicateMapping: undefined,
    potentialShadowing: undefined,
  };
}

export const ValidationIssue: MessageFns<ValidationIssue> = {
  encode(message: ValidationIssue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keybindConflict !== undefined) {
      KeybindConflict.encode(message.keybindConflict, writer.uint32(10).fork()).join();
    }
    if (message.danglingAction !== undefined) {
      DanglingAction.encode(message.danglingAction, writer.uint32(18).fork()).join();
    }
    if (message.unsupportedAction !== undefined) {
      UnsupportedAction.encode(message.unsupportedAction, writer.uint32(26).fork()).join();
    }
    if (message.duplicateMapping !== undefined) {
      DuplicateMapping.encode(message.duplicateMapping, writer.uint32(34).fork()).join();
    }
    if (message.potentialShadowing !== undefined) {
      PotentialShadowing.encode(message.potentialShadowing, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationIssue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationIssue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keybindConflict = KeybindConflict.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.danglingAction = DanglingAction.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.unsupportedAction = UnsupportedAction.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.duplicateMapping = DuplicateMapping.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.potentialShadowing = PotentialShadowing.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationIssue {
    return {
      keybindConflict: isSet(object.keybindConflict)
        ? KeybindConflict.fromJSON(object.keybindConflict)
        : isSet(object.keybind_conflict)
        ? KeybindConflict.fromJSON(object.keybind_conflict)
        : undefined,
      danglingAction: isSet(object.danglingAction)
        ? DanglingAction.fromJSON(object.danglingAction)
        : isSet(object.dangling_action)
        ? DanglingAction.fromJSON(object.dangling_action)
        : undefined,
      unsupportedAction: isSet(object.unsupportedAction)
        ? UnsupportedAction.fromJSON(object.unsupportedAction)
        : isSet(object.unsupported_action)
        ? UnsupportedAction.fromJSON(object.unsupported_action)
        : undefined,
      duplicateMapping: isSet(object.duplicateMapping)
        ? DuplicateMapping.fromJSON(object.duplicateMapping)
        : isSet(object.duplicate_mapping)
        ? DuplicateMapping.fromJSON(object.duplicate_mapping)
        : undefined,
      potentialShadowing: isSet(object.potentialShadowing)
        ? PotentialShadowing.fromJSON(object.potentialShadowing)
        : isSet(object.potential_shadowing)
        ? PotentialShadowing.fromJSON(object.potential_shadowing)
        : undefined,
    };
  },

  toJSON(message: ValidationIssue): unknown {
    const obj: any = {};
    if (message.keybindConflict !== undefined) {
      obj.keybindConflict = KeybindConflict.toJSON(message.keybindConflict);
    }
    if (message.danglingAction !== undefined) {
      obj.danglingAction = DanglingAction.toJSON(message.danglingAction);
    }
    if (message.unsupportedAction !== undefined) {
      obj.unsupportedAction = UnsupportedAction.toJSON(message.unsupportedAction);
    }
    if (message.duplicateMapping !== undefined) {
      obj.duplicateMapping = DuplicateMapping.toJSON(message.duplicateMapping);
    }
    if (message.potentialShadowing !== undefined) {
      obj.potentialShadowing = PotentialShadowing.toJSON(message.potentialShadowing);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidationIssue>, I>>(base?: I): ValidationIssue {
    return ValidationIssue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidationIssue>, I>>(object: I): ValidationIssue {
    const message = createBaseValidationIssue();
    message.keybindConflict = (object.keybindConflict !== undefined && object.keybindConflict !== null)
      ? KeybindConflict.fromPartial(object.keybindConflict)
      : undefined;
    message.danglingAction = (object.danglingAction !== undefined && object.danglingAction !== null)
      ? DanglingAction.fromPartial(object.danglingAction)
      : undefined;
    message.unsupportedAction = (object.unsupportedAction !== undefined && object.unsupportedAction !== null)
      ? UnsupportedAction.fromPartial(object.unsupportedAction)
      : undefined;
    message.duplicateMapping = (object.duplicateMapping !== undefined && object.duplicateMapping !== null)
      ? DuplicateMapping.fromPartial(object.duplicateMapping)
      : undefined;
    message.potentialShadowing = (object.potentialShadowing !== undefined && object.potentialShadowing !== null)
      ? PotentialShadowing.fromPartial(object.potentialShadowing)
      : undefined;
    return message;
  },
};

function createBaseKeybindConflict(): KeybindConflict {
  return { keybinding: "", actions: [] };
}

export const KeybindConflict: MessageFns<KeybindConflict> = {
  encode(message: KeybindConflict, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keybinding !== "") {
      writer.uint32(10).string(message.keybinding);
    }
    for (const v of message.actions) {
      KeybindConflict_Action.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeybindConflict {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeybindConflict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keybinding = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.actions.push(KeybindConflict_Action.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeybindConflict {
    return {
      keybinding: isSet(object.keybinding) ? globalThis.String(object.keybinding) : "",
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => KeybindConflict_Action.fromJSON(e))
        : [],
    };
  },

  toJSON(message: KeybindConflict): unknown {
    const obj: any = {};
    if (message.keybinding !== "") {
      obj.keybinding = message.keybinding;
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => KeybindConflict_Action.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeybindConflict>, I>>(base?: I): KeybindConflict {
    return KeybindConflict.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeybindConflict>, I>>(object: I): KeybindConflict {
    const message = createBaseKeybindConflict();
    message.keybinding = object.keybinding ?? "";
    message.actions = object.actions?.map((e) => KeybindConflict_Action.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKeybindConflict_Action(): KeybindConflict_Action {
  return { action: "", editorCommand: "" };
}

export const KeybindConflict_Action: MessageFns<KeybindConflict_Action> = {
  encode(message: KeybindConflict_Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    if (message.editorCommand !== "") {
      writer.uint32(18).string(message.editorCommand);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeybindConflict_Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeybindConflict_Action();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.editorCommand = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeybindConflict_Action {
    return {
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      editorCommand: isSet(object.editorCommand)
        ? globalThis.String(object.editorCommand)
        : isSet(object.editor_command)
        ? globalThis.String(object.editor_command)
        : "",
    };
  },

  toJSON(message: KeybindConflict_Action): unknown {
    const obj: any = {};
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.editorCommand !== "") {
      obj.editorCommand = message.editorCommand;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeybindConflict_Action>, I>>(base?: I): KeybindConflict_Action {
    return KeybindConflict_Action.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeybindConflict_Action>, I>>(object: I): KeybindConflict_Action {
    const message = createBaseKeybindConflict_Action();
    message.action = object.action ?? "";
    message.editorCommand = object.editorCommand ?? "";
    return message;
  },
};

function createBaseDanglingAction(): DanglingAction {
  return { action: "", keybinding: "", suggestion: "" };
}

export const DanglingAction: MessageFns<DanglingAction> = {
  encode(message: DanglingAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    if (message.keybinding !== "") {
      writer.uint32(18).string(message.keybinding);
    }
    if (message.suggestion !== "") {
      writer.uint32(26).string(message.suggestion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DanglingAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDanglingAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keybinding = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.suggestion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DanglingAction {
    return {
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      keybinding: isSet(object.keybinding) ? globalThis.String(object.keybinding) : "",
      suggestion: isSet(object.suggestion) ? globalThis.String(object.suggestion) : "",
    };
  },

  toJSON(message: DanglingAction): unknown {
    const obj: any = {};
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.keybinding !== "") {
      obj.keybinding = message.keybinding;
    }
    if (message.suggestion !== "") {
      obj.suggestion = message.suggestion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DanglingAction>, I>>(base?: I): DanglingAction {
    return DanglingAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DanglingAction>, I>>(object: I): DanglingAction {
    const message = createBaseDanglingAction();
    message.action = object.action ?? "";
    message.keybinding = object.keybinding ?? "";
    message.suggestion = object.suggestion ?? "";
    return message;
  },
};

function createBaseUnsupportedAction(): UnsupportedAction {
  return { action: "", keybinding: "", targetEditor: "" };
}

export const UnsupportedAction: MessageFns<UnsupportedAction> = {
  encode(message: UnsupportedAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    if (message.keybinding !== "") {
      writer.uint32(18).string(message.keybinding);
    }
    if (message.targetEditor !== "") {
      writer.uint32(26).string(message.targetEditor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnsupportedAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnsupportedAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keybinding = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetEditor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnsupportedAction {
    return {
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      keybinding: isSet(object.keybinding) ? globalThis.String(object.keybinding) : "",
      targetEditor: isSet(object.targetEditor)
        ? globalThis.String(object.targetEditor)
        : isSet(object.target_editor)
        ? globalThis.String(object.target_editor)
        : "",
    };
  },

  toJSON(message: UnsupportedAction): unknown {
    const obj: any = {};
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.keybinding !== "") {
      obj.keybinding = message.keybinding;
    }
    if (message.targetEditor !== "") {
      obj.targetEditor = message.targetEditor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnsupportedAction>, I>>(base?: I): UnsupportedAction {
    return UnsupportedAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnsupportedAction>, I>>(object: I): UnsupportedAction {
    const message = createBaseUnsupportedAction();
    message.action = object.action ?? "";
    message.keybinding = object.keybinding ?? "";
    message.targetEditor = object.targetEditor ?? "";
    return message;
  },
};

function createBaseDuplicateMapping(): DuplicateMapping {
  return { action: "", keybinding: "", message: "" };
}

export const DuplicateMapping: MessageFns<DuplicateMapping> = {
  encode(message: DuplicateMapping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    if (message.keybinding !== "") {
      writer.uint32(18).string(message.keybinding);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuplicateMapping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuplicateMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keybinding = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuplicateMapping {
    return {
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      keybinding: isSet(object.keybinding) ? globalThis.String(object.keybinding) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DuplicateMapping): unknown {
    const obj: any = {};
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.keybinding !== "") {
      obj.keybinding = message.keybinding;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuplicateMapping>, I>>(base?: I): DuplicateMapping {
    return DuplicateMapping.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuplicateMapping>, I>>(object: I): DuplicateMapping {
    const message = createBaseDuplicateMapping();
    message.action = object.action ?? "";
    message.keybinding = object.keybinding ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBasePotentialShadowing(): PotentialShadowing {
  return { keybinding: "", action: "", targetEditor: "", message: "" };
}

export const PotentialShadowing: MessageFns<PotentialShadowing> = {
  encode(message: PotentialShadowing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keybinding !== "") {
      writer.uint32(10).string(message.keybinding);
    }
    if (message.action !== "") {
      writer.uint32(18).string(message.action);
    }
    if (message.targetEditor !== "") {
      writer.uint32(26).string(message.targetEditor);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PotentialShadowing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePotentialShadowing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keybinding = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetEditor = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PotentialShadowing {
    return {
      keybinding: isSet(object.keybinding) ? globalThis.String(object.keybinding) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      targetEditor: isSet(object.targetEditor)
        ? globalThis.String(object.targetEditor)
        : isSet(object.target_editor)
        ? globalThis.String(object.target_editor)
        : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: PotentialShadowing): unknown {
    const obj: any = {};
    if (message.keybinding !== "") {
      obj.keybinding = message.keybinding;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.targetEditor !== "") {
      obj.targetEditor = message.targetEditor;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PotentialShadowing>, I>>(base?: I): PotentialShadowing {
    return PotentialShadowing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PotentialShadowing>, I>>(object: I): PotentialShadowing {
    const message = createBasePotentialShadowing();
    message.keybinding = object.keybinding ?? "";
    message.action = object.action ?? "";
    message.targetEditor = object.targetEditor ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
